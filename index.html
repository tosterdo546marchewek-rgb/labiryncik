<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>The Lab - Deep Observation</title>
<style>
    body { margin: 0; overflow: hidden; background: black; font-family: 'Courier New', Courier, monospace; }
    canvas { display: block; }
    #ui {
        position: absolute; top: 20px; right: 20px;
        color: #0f0; text-align: right; pointer-events: none;
        text-shadow: 2px 2px black;
    }
    #overlay {
        position: absolute; width: 100%; height: 100%;
        display: flex; justify-content: center; align-items: center;
        color: white; background: rgba(0,0,0,0.95); cursor: pointer;
        z-index: 10; font-size: 20px; text-align: center;
    }
</style>
</head>
<body>
<div id="overlay">INICJACJA PROTOKOŁU BADANIA<br>(WSAD + STRZAŁKI, F - LATARKA)<br><br>STAŃ NA PRÓBCE, ABY JĄ ZESKANOWAĆ</div>
<div id="ui">
    <div id="task">ZADANIE: POBIERZ 30 PRÓBEK</div>
    <div id="counter">ZEBRANO: 0/30</div>
    <div id="timer" style="display:none;">EWAKUACJA ZA: 02:00</div>
</div>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const overlay = document.getElementById("overlay");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let audioCtx, mainGain, droneOsc;
let runTexts = [];

function initAudio() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    mainGain = audioCtx.createGain();
    mainGain.connect(audioCtx.destination);
    mainGain.gain.value = 0.3;
    droneOsc = audioCtx.createOscillator();
    droneOsc.type = 'sawtooth';
    droneOsc.frequency.setValueAtTime(40, audioCtx.currentTime);
    let lp = audioCtx.createBiquadFilter();
    lp.type = "lowpass"; lp.frequency.value = 150;
    droneOsc.connect(lp); lp.connect(mainGain);
    droneOsc.start();
}

function playJS() {
    if(!audioCtx) return;
    let o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = 'square'; o.frequency.setValueAtTime(80, audioCtx.currentTime);
    o.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 1);
    g.gain.setValueAtTime(1, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 1);
    o.connect(g); g.connect(audioCtx.destination); o.start();
}

// POWIĘKSZONA MAPA (15x15)
const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,0,1,0,1,1,1,1,1,0,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,1,0,1,0,1],
    [1,0,1,1,1,1,1,1,1,0,1,0,1,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,1,0,1],
    [1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],
    [1,0,0,0,0,0,1,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,0,1,1,1,1,1,1,1,0,1],
    [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
    [1,0,1,0,1,1,1,1,1,1,1,0,1,0,1],
    [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
    [1,1,1,0,1,0,1,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

let player = { x: 1.5, y: 1.5, angle: 0, speed: 0.07, rotSpeed: 0.05 };
let monster = { x: 0, y: 0, active: false, mode: null, timer: 0, speed: 0.055, spawnTime: 0, despawnTime: 0 };
let gameStart, gameRunning = false, isGameOver = false, flashlight = true, keys = {};
let items = [], itemsCollected = 0, totalNeeded = 30, fakeTimer = 120;

function spawnItems() {
    while(items.length < totalNeeded) {
        let rx = Math.floor(Math.random()*13)+1, ry = Math.floor(Math.random()*13)+1;
        if(map[ry][rx] === 0 && !(rx==1 && ry==1)) {
            items.push({x: rx + 0.5, y: ry + 0.5, progress: 0});
        }
    }
}

overlay.addEventListener("click", () => {
    overlay.style.display = "none";
    gameRunning = true;
    initAudio();
    gameStart = Date.now();
    spawnItems();
    setInterval(() => { if(itemsCollected >= totalNeeded && fakeTimer > 0) fakeTimer--; }, 1000);
});

document.addEventListener("keydown", e => { keys[e.key.toLowerCase()] = true; if(e.key.toLowerCase() === "f") flashlight = !flashlight; });
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

function spawnMonster() {
    if (isGameOver || monster.active || !gameRunning) return;
    let timeElapsed = Date.now() - gameStart;
    if (timeElapsed < 30000) return; 

    let isHell = timeElapsed > 150000;
    
    // W fazie Hell ignorujemy interwał i atakujemy niemal ciągle
    if (!isHell && Math.random() < 0.3) return; // Dodatkowa losowość dla "złudzenia"

    let dist = isHell ? 3.0 : 4.0, angle = player.angle + (Math.random() - 0.5);
    monster.x = player.x + Math.cos(angle) * dist;
    monster.y = player.y + Math.sin(angle) * dist;
    
    if(map[Math.floor(monster.y)][Math.floor(monster.x)] === 1) return;
    
    monster.spawnTime = Date.now();
    monster.despawnTime = Date.now() + 400; // ZAWSZE ZNIKA PO 0.4s (chyba że to Chase)
    monster.active = true;
    monster.mode = isHell ? "chase" : (Math.random() > 0.5 ? "flash" : "behind");
}

// POTWÓR CO 22 SEKUNDY (W fazie normalnej)
setInterval(() => {
    let timeElapsed = Date.now() - gameStart;
    if (timeElapsed < 150000) spawnMonster();
}, 22000);

// W fazie Hell potwór sprawdza spawn co 1.5s
setInterval(() => {
    let timeElapsed = Date.now() - gameStart;
    if (timeElapsed >= 150000) spawnMonster();
}, 1500);

function triggerJumpscare() {
    isGameOver = true; playJS(); let frame = 0;
    function animate() {
        if (frame > 45) {
            ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle="black"; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle="#f00"; ctx.font="bold 45px Courier New"; ctx.textAlign="center";
            ctx.fillText("y0u aRen'T we1lc0mE heRe", canvas.width/2, canvas.height/2);
            setTimeout(() => { window.location.href="about:blank"; }, 1500); return;
        }
        ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle="black"; ctx.fillRect(0,0,canvas.width,canvas.height);
        for(let i=0;i<40;i++){ ctx.fillStyle="red"; ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, Math.random()*600, 3); }
        let s = 1 + (frame*0.25); ctx.save(); ctx.translate(canvas.width/2+(Math.random()-0.5)*80, canvas.height/2+(Math.random()-0.5)*80); ctx.scale(s,s);
        ctx.fillStyle="#0a0a0a"; ctx.beginPath(); ctx.arc(0,0,150,0,Math.PI*2); ctx.fill();
        ctx.fillStyle="red"; ctx.shadowBlur=50; ctx.shadowColor="red";
        ctx.beginPath(); ctx.arc(-50,-30,25,0,Math.PI*2); ctx.arc(50,-30,25,0,Math.PI*2); ctx.fill();
        ctx.fillStyle="black"; ctx.beginPath(); ctx.ellipse(0,70,50,90,0,0,Math.PI*2); ctx.fill(); ctx.restore();
        frame++; requestAnimationFrame(animate);
    }
    animate();
}

function draw() {
    if(!gameRunning || isGameOver) { requestAnimationFrame(draw); return; }
    let timeElapsed = Date.now() - gameStart, isHell = timeElapsed > 150000;

    document.getElementById("counter").innerText = `ZEBRANO: ${itemsCollected}/${totalNeeded}`;
    if(itemsCollected >= totalNeeded) {
        document.getElementById("task").innerText = "ZADANIE: PRZEŻYJ";
        document.getElementById("timer").style.display = "block";
        let m = Math.floor(fakeTimer/60), s = fakeTimer%60;
        document.getElementById("timer").innerText = `EWAKUACJA ZA: 0${m}:${s<10?'0':''}${s}`;
    }

    if (keys["w"] || keys["arrowup"]) {
        let nx = player.x + Math.cos(player.angle)*player.speed, ny = player.y + Math.sin(player.angle)*player.speed;
        if(map[Math.floor(ny)][Math.floor(nx)] === 0) { player.x = nx; player.y = ny; }
    }
    if (keys["s"] || keys["arrowdown"]) {
        let nx = player.x - Math.cos(player.angle)*player.speed, ny = player.y - Math.sin(player.angle)*player.speed;
        if(map[Math.floor(ny)][Math.floor(nx)] === 0) { player.x = nx; player.y = ny; }
    }
    if (keys["a"] || keys["arrowleft"]) player.angle -= player.rotSpeed;
    if (keys["d"] || keys["arrowright"]) player.angle += player.rotSpeed;

    items.forEach((it, index) => {
        let d = Math.sqrt((it.x-player.x)**2 + (it.y-player.y)**2);
        if(d < 0.4) {
            it.progress += 0.009;
            if(it.progress >= 1) { items.splice(index, 1); itemsCollected++; }
        } else if(it.progress > 0) it.progress -= 0.005;
    });

    ctx.save();
    if(isHell) ctx.translate((Math.random()-0.5)*15, (Math.random()-0.5)*15);
    ctx.fillStyle = "black"; ctx.fillRect(0,0,canvas.width,canvas.height);

    const fov = Math.PI/3;
    for (let i = 0; i < canvas.width; i++) {
        let rayAngle = (player.angle - fov/2) + (i/canvas.width)*fov, d = 0, hit = false;
        while (!hit && d < 15) { d += 0.05; if (map[Math.floor(player.y+Math.sin(rayAngle)*d)][Math.floor(player.x+Math.cos(rayAngle)*d)] === 1) hit = true; }
        let h = canvas.height/(d*1.5), b = flashlight ? Math.max(0, 255-d*40) : Math.max(0, 40-d*10);
        ctx.fillStyle = `rgb(${b+(isHell?110:0)},${isHell?b*0.05:b},${isHell?b*0.05:b})`; ctx.fillRect(i, (canvas.height-h)/2, 1, h);
    }

    items.forEach(it => {
        let dx = it.x-player.x, dy = it.y-player.y, d = Math.sqrt(dx*dx+dy*dy), a = Math.atan2(dy, dx)-player.angle;
        while(a > Math.PI) a -= 2*Math.PI; while(a < -Math.PI) a += 2*Math.PI;
        if(Math.abs(a) < fov/2) {
            let s = canvas.height/(d*4.5), x = canvas.width/2 + Math.tan(a)*canvas.width/2;
            ctx.fillStyle = `rgb(${it.progress*255},${(1-it.progress)*255},0)`;
            ctx.fillRect(x-s/2, canvas.height/2, s, s);
            if(it.progress > 0) { ctx.fillStyle = "white"; ctx.fillRect(x-s/2, canvas.height/2 - 10, s * it.progress, 4); }
        }
    });

    if (monster.active) {
        let dx = monster.x-player.x, dy = monster.y-player.y, d = Math.sqrt(dx*dx+dy*dy);
        if (isHell || monster.mode === "chase") {
            monster.x -= (dx/d)*monster.speed; monster.y -= (dy/d)*monster.speed;
            if(d < 0.35) triggerJumpscare();
        } else if (Date.now() > monster.despawnTime) {
            monster.active = false;
        }

        if (monster.active) {
            let a = Math.atan2(dy, dx)-player.angle; while(a > Math.PI) a -= 2*Math.PI; while(a < -Math.PI) a += 2*Math.PI;
            if(Math.abs(a) < Math.PI/2) {
                let s = canvas.height/(d*1.5), x = canvas.width/2 + Math.tan(a)*canvas.width/2;
                ctx.save(); ctx.translate(x, canvas.height/2); ctx.fillStyle="#050505"; ctx.fillRect(-s/8,-s/4,s/4,s);
                ctx.beginPath(); ctx.arc(0,-s/2.5,s/6,0,Math.PI*2); ctx.fill();
                ctx.fillStyle="red"; ctx.beginPath(); ctx.arc(-s/15,-s/2.2,s/40,0,Math.PI*2); ctx.arc(s/15,-s/2.2,s/40,0,Math.PI*2); ctx.fill(); ctx.restore();
            }
        }
    }

    if (isHell) {
        if(Math.random() > 0.85) { runTexts.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, life: 30, size: 20 + Math.random()*40 }); }
        ctx.fillStyle = "red"; ctx.textAlign = "center";
        runTexts.forEach((rt, idx) => {
            ctx.font = `bold ${rt.size}px Courier New`;
            ctx.fillText("RUN", rt.x, rt.y);
            rt.life--; if(rt.life <= 0) runTexts.splice(idx, 1);
        });
        if(Math.random()>0.9) { ctx.fillStyle="rgba(255,0,0,0.3)"; ctx.fillRect(0,0,canvas.width,canvas.height); }
    }

    ctx.restore(); requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>